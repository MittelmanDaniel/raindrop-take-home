// ClickHouse SQL Grammar - Simplified for CFG
// Uses actual spaces and operators directly in rules

// ---------- Terminals ----------
IDENTIFIER: /[a-zA-Z_][a-zA-Z0-9_]*/
NUMBER: /[0-9]+/
STRING_LITERAL: /'[^']*'/

// ---------- SQL Keywords ----------
SELECT: "SELECT"
FROM: "FROM"
WHERE: "WHERE"
GROUP: "GROUP"
BY: "BY"
ORDER: "ORDER"
LIMIT: "LIMIT"
HAVING: "HAVING"
AS: "AS"
DISTINCT: "DISTINCT"
AND: "AND"
OR: "OR"
LIKE: "LIKE"
ILIKE: "ILIKE"
IN: "IN"
NOT: "NOT"
IS: "IS"
NULL: "NULL"
ASC: "ASC"
DESC: "DESC"
FORMAT: "FORMAT"
JSON: "JSON"
CASE: "CASE"
WHEN: "WHEN"
THEN: "THEN"
ELSE: "ELSE"
END: "END"
BETWEEN: "BETWEEN"
CAST: "CAST"

// ---------- Main query structure ----------
start: select_stmt " FORMAT JSON" [";"]

select_stmt: SELECT " " ["DISTINCT "] select_elements " FROM " table_name [where_clause] [group_by_clause] [having_clause] [order_by_clause] [limit_clause]

// ---------- Select elements ----------
select_elements: "*" | select_element | select_element ", " select_elements
select_element: column_expr | column_expr " AS " identifier | column_expr " " identifier

// ---------- Column expressions (with binary operators) ----------
column_expr: column_expr_term
           | column_expr " + " column_expr_term -> add_expr
           | column_expr " - " column_expr_term -> sub_expr
           | column_expr " * " column_expr_term -> mul_expr
           | column_expr " / " column_expr_term -> div_expr
           | column_expr " % " column_expr_term -> mod_expr
           | column_expr " || " column_expr_term -> concat_expr

column_expr_term: column_identifier
                | aggregate_func
                | function_call
                | general_func
                | literal
                | "(" column_expr ")"
                | "CASE " when_clause+ [" ELSE " column_expr] " END"
                | "CAST(" column_expr " AS " data_type ")"

column_identifier: identifier

// ---------- Functions ----------
function_call: identifier "(" function_args ")"
             | identifier "(DISTINCT " function_args ")"
             | identifier "()"
function_args: column_expr | column_expr ", " function_args

// Common string functions
string_func: "length(" column_expr ")"
           | "upper(" column_expr ")"
           | "lower(" column_expr ")"
           | "substring(" column_expr ", " NUMBER ", " NUMBER ")"
           | "substring(" column_expr ", " NUMBER ")"
           | "concat(" function_args ")"
           | "trim(" column_expr ")"
           | "ltrim(" column_expr ")"
           | "rtrim(" column_expr ")"

// Common date/time functions
date_func: "toDate(" column_expr ")"
         | "toDateTime(" column_expr ")"
         | "formatDateTime(" column_expr ", " STRING_LITERAL ")"
         | "toStartOfDay(" column_expr ")"
         | "toStartOfMonth(" column_expr ")"
         | "toStartOfYear(" column_expr ")"
         | "toYear(" column_expr ")"
         | "toMonth(" column_expr ")"
         | "toDayOfMonth(" column_expr ")"
         | "now()"

// Common math functions
math_func: "abs(" column_expr ")"
         | "round(" column_expr ")"
         | "round(" column_expr ", " NUMBER ")"
         | "floor(" column_expr ")"
         | "ceil(" column_expr ")"
         | "sqrt(" column_expr ")"
         | "pow(" column_expr ", " NUMBER ")"
         | "log(" column_expr ")"

// Common conditional functions
conditional_func: "if(" column_expr ", " column_expr ", " column_expr ")"
                | "coalesce(" function_args ")"
                | "isNull(" column_expr ")"
                | "isNotNull(" column_expr ")"

// All function types
general_func: string_func | date_func | math_func | conditional_func

aggregate_func: count_func | sum_func | avg_func | min_func | max_func | stddev_func | variance_func | quantile_func
count_func: "count(*)" | "count(DISTINCT " column_expr ")" | "count()"
sum_func: "sum(" column_expr ")"
avg_func: "avg(" column_expr ")"
min_func: "min(" column_expr ")"
max_func: "max(" column_expr ")"
stddev_func: "stddevPop(" column_expr ")" | "stddevPopStable(" column_expr ")" | "stddevSamp(" column_expr ")" | "stddevSampStable(" column_expr ")"
variance_func: "varPop(" column_expr ")" | "varSamp(" column_expr ")"
quantile_func: "quantile(" column_expr ")" | "quantile(" NUMBER ")(" column_expr ")"

// Fixed table name
table_name: "IBM_HR_Employee_Attrition"

// ---------- Clauses (operators allowed here) ----------
where_clause: " WHERE " condition
condition: predicate | condition " AND " condition | condition " OR " condition | "(" condition ")"
predicate: column_expr " = " value
         | column_expr " != " value
         | column_expr " > " value
         | column_expr " < " value
         | column_expr " >= " value
         | column_expr " <= " value
         | column_expr " IS " ["NOT "] NULL
         | column_expr [" NOT"] " LIKE " STRING_LITERAL
         | column_expr [" NOT"] " ILIKE " STRING_LITERAL
         | column_expr [" NOT"] " IN (" value_list ")"
         | column_expr " BETWEEN " value " AND " value

group_by_clause: " GROUP BY " group_by_list
group_by_list: column_expr | column_expr ", " group_by_list
having_clause: " HAVING " condition
order_by_clause: " ORDER BY " order_by_list
order_by_list: order_by_item | order_by_item ", " order_by_list
order_by_item: column_expr [" ASC" | " DESC"]
limit_clause: " LIMIT " NUMBER

// ---------- Case expressions ----------
when_clause: "WHEN " condition " THEN " column_expr

// ---------- Literals and values ----------
literal: NUMBER | STRING_LITERAL | NULL
value: column_expr
value_list: value | value ", " value_list

// ---------- Data types (for CAST) ----------
data_type: "Int8" | "Int16" | "Int32" | "Int64"
         | "UInt8" | "UInt16" | "UInt32" | "UInt64"
         | "Float32" | "Float64"
         | "String" | "Date" | "DateTime"

identifier: IDENTIFIER
